
#define _CRT_SECURE_NO_WARNINGS
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define ASSEMBLE_INTERNAL

//#include "forge.h"
#include "assemble_json.h"


#define FALSE 0
#define TRUE !FALSE


#define ASSEMBLE_JSON_TYPE_MASK (0x01 | 0x02 | 0x04 | 0x08) /* 4 first bits reserved for type*/
#define ASSEMBLE_JSON_CATEGORY_MASK (0x01 | 0x02 | 0x04) /* 3 first bits reserved for type*/
#define ASSEMBLE_JSON_ARRAY 0x10
#define ASSEMBLE_JSON_ARRAY_FOLOW 0x20
#define ASSEMBLE_JSON_ROOT 0x40 
#define ASSEMBLE_JSON_WRITE_PROTECTED 0x80 
#define ASSEMBLE_JSON_ENABLE_PARSE_ERRORS

#define ASSEMBLE_JSON_ARRAY_UNIFORM 0x80000000

const double assemble_double_decimal_lookup_table[] = {1.0,
													0.1,
													0.01,
													0.001,
													0.0001,
													0.00001,
													0.000001,
													0.0000001,
													0.00000001,
													0.000000001,
													0.0000000001,
													0.00000000001,
													0.000000000001,
													0.0000000000001,
													0.00000000000001,
													0.000000000000001,
													0.0000000000000001,
													0.00000000000000001,
													0.000000000000000001,
													0.0000000000000000001,
													0.00000000000000000001,
													0.000000000000000000001,
													0.0000000000000000000001,
													0.00000000000000000000001,
													0.000000000000000000000001,
													0.0000000000000000000000001,
													0.00000000000000000000000001,
													0.000000000000000000000000001,
													0.0000000000000000000000000001,
													0.00000000000000000000000000001,
													0.000000000000000000000000000001,
													0.0000000000000000000000000000001,
													0.00000000000000000000000000000001,
													0.000000000000000000000000000000001,
													0.0000000000000000000000000000000001,
													0.00000000000000000000000000000000001,
													0.000000000000000000000000000000000001,
													0.0000000000000000000000000000000000001,
													0.00000000000000000000000000000000000001,
													0.000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001, 
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001, 
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001};


const float assemble_float_decimal_lookup_table[] = {1.0,
													0.1,
													0.01,
													0.001,
													0.0001,
													0.00001,
													0.000001,
													0.0000001,
													0.00000001,
													0.000000001,
													0.0000000001,
													0.00000000001,
													0.000000000001,
													0.0000000000001,
													0.00000000000001,
													0.000000000000001,
													0.0000000000000001,
													0.00000000000000001,
													0.000000000000000001,
													0.0000000000000000001,
													0.00000000000000000001,
													0.000000000000000000001,
													0.0000000000000000000001,
													0.00000000000000000000001,
													0.000000000000000000000001,
													0.0000000000000000000000001,
													0.00000000000000000000000001,
													0.000000000000000000000000001,
													0.0000000000000000000000000001,
													0.00000000000000000000000000001,
													0.000000000000000000000000000001,
													0.0000000000000000000000000000001,
													0.00000000000000000000000000000001,
													0.000000000000000000000000000000001,
													0.0000000000000000000000000000000001,
													0.00000000000000000000000000000000001,
													0.000000000000000000000000000000000001,
													0.0000000000000000000000000000000000001,
													0.00000000000000000000000000000000000001,
													0.000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001, 
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001, 
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
													0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001};

const int assemble_type_size[] = {1, // A_JT_BOOLEAN / A_JT_FALSE,
									1 + sizeof(float), // A_JT_NUMBER_FLOAT,
									1 + sizeof(void *), // A_JT_STRING,									
									1 + sizeof(void *), // A_JT_OBJECT,
									1 + sizeof(void *) + sizeof(AJasonArrayCount), // A_JT_ARRAY,									
									1, // A_JT_NULL, (5)
									1, // A_JT_TRUE, (6)
									1 + sizeof(double), // A_JT_NUMBER_DOUBLE (7)
									0, // 8
									0, // 9
									0, // 10
									0, // 11
									0, // 12
									1 + sizeof(int64) + 1, // A_JT_NUMBER_DECIMAL (13)
									0, // 14
									0}; // 15


const int assemble_type_append[] = {TRUE, // A_JT_FALSE,
									TRUE, // A_JT_NUMBER,
									FALSE, // A_JT_STRING,									
									FALSE, // A_JT_OBJECT,
									FALSE, // A_JT_ARRAY,									
									TRUE, // A_JT_NULL,
									TRUE, // A_JT_TRUE, (6)
									TRUE, // A_JT_NUMBER_DOUBLE (7)
									TRUE, // 8
									TRUE, // 9
									TRUE, // 10
									TRUE, // 11
									TRUE, // 12
									TRUE, // A_JT_NUMBER_DECIMAL (13)
									TRUE, // 14
									TRUE}; // 15


extern double assemble_json_value_number_get_double(uint8 *value);
extern float assemble_json_value_number_get_float(uint8 *value);
extern void assemble_json_value_number_get_decimal(uint8 *value, AJsonDecimalNumber *decimal);
extern int64 assemble_json_value_number_get_integer(uint8 *value);

extern uint assemble_json_parse_object(unsigned char *link, const char *string, uint8 **memory, AJsonType number_type);
extern uint assemble_json_messure_object(const char *string, size_t *memory, AJsonType number_type);

uint assemble_json_decimal_parce(char *text, int64 *real_output, uint8 *decimal)
{
	int64 out = 0;
	double divider = 0.1, neg = 1.0;
	uint i = 0, c = ~0;
	if(text[0] == '-')
		i = 1;		
	while(TRUE)
	{
		if(text[i] >= '0' && text[i] <= '9')
		{
			out *= 10;
			out += text[i] - '0';
		}else if(text[i] == '.')
			c = i + 1;
		else 
			break;
		i++;
	}
	while(c < i)
	{
		if(out % 10 != 0)
			break;
		out /= 10;
		c++;
	}
	if(c < i)
		*decimal = i - c;
	else
		*decimal = 0;
	if(text[0] == '-')
		*real_output = -out;
	else
		*real_output = out;
	return i;
}

uint assemble_json_decimal_print(char *text, int64 real, uint8 decimal)
{
	int64 tmp;
	char *t;
	uint i, j;
	t = text;
	if(real < 0)
	{
		*t++ = '-';
		real = -real;
	}
	tmp = real;
	for(i = 0; tmp != 0; i++)
		tmp /= 10;
	tmp = real;
	if(decimal == 0)
	{
		if(i == 0)
		{
			*t = '0';
			return 1;
		}
		for(j = i; j != 0;)
		{		
			t[--j] = '0' + tmp % 10;
			tmp /= 10; 
		}
		t += i;
		return t - text;
	}else if(decimal < i)
	{
		i++;
		j = i;
		while(j + decimal != i)
		{			
			t[--j] = '0' + tmp % 10;
			tmp /= 10; 
		}
		t[--j] = '.';
		while(j != 0)
		{		
			t[--j] = '0' + tmp % 10;
			tmp /= 10; 
		}
		t += i; 
		return t - text;		
	}else
	{
		*t++ = '0';
		*t++ = '.';
		for(j = i; j < decimal; j++)
			*t++ = '0';
		for(j = i; j != 0;)
		{		
			t[--j] = '0' + tmp % 10;
			tmp /= 10; 
		}
		t += i;
		return t - text;
	}
}

uint assemble_json_decimal_print_size(int64 integer, uint8 decimal)
{
	int64 tmp;
	uint i, neg = 0;
	if(integer < 0)
	{
		neg = 1;
		tmp = -integer;
	}else
		tmp = integer;
	for(i = 0; tmp != 0; i++)
		tmp /= 10;
	tmp = integer;
	if(decimal == 0)
	{
		if(i == 0)	
			return neg + 1;
		else
			return neg + i;
	}else if(decimal < i)
	{
		return neg + i + 1;		
	}else
	{
		return decimal + 2;
	}
}

uint assemble_parce_number(char *text, double *real_output)
{
	double out = 0;
	double divider = 0.1, neg = 1.0;
	uint i = 0;
	if(text[0] == '-')
	{
		neg = -1.0;
		i = 1;
	}		
	while(TRUE)
	{
		if(text[i] >= '0' && text[i] <= '9')
		{
			out *= 10.0;
			out += text[i] - '0';
		}else
		{
			if(text[i] == '.')
				break;
			*real_output = out * neg;
			return i;
		}
		i++;
	}
	i++;
	while(TRUE)
	{
		if(text[i] >= '0' && text[i] <= '9')
			out += divider * (double)(text[i] - '0');
		else
		{
			*real_output = out * neg;
			return i;
		}
		divider /= 10.0;
		i++;
	}
}

void assemble_json_string_parse_size(const char *string, uint *string_pos, uint *output_pos)
{
	uint i = 0, pos;
	for(pos = 0; string[pos] != '"' && string[pos] != 0; pos++)
	{
		if(string[pos] == '\\')
		{
			pos++;
			switch(string[pos])
			{
				case '"':
				case 'b':
				case 'f':
				case 'n':
				case 'r':
				case 't':
				case '\\':
				i++;
				break;
			}
		}else
			i++;
	}
	*string_pos += pos; 
	*output_pos += i; 
}

void assemble_json_string_parse(const char *string, char *output, uint *string_pos, uint *output_pos)
{
	uint i = 0, pos;
	for(pos = 0; string[pos] != '"' && string[pos] != 0; pos++)
	{
		if(string[pos] == '\\')
		{
			pos++;
			switch(string[pos])
			{
				case '"':
				output[i++] = '"';
				break;
				case 'b':
				output[i++] = '\b';
				break;
				case 'f':
				output[i++] = '\f';
				break;
				case 'n':
				output[i++] = '\n';
				break;
				case 'r':
				output[i++] = '\r';
				break;
				case 't':
				output[i++] = '\t';
				break;
				case '\\':
				output[i++] = '\\';
				break;
			}
		}else
			output[i++] = string[pos];
	}
	output[i++] = 0;
	*string_pos += pos; 
	*output_pos += i; 
}

uint assemble_json_string_print_size(const char *string, uint *string_pos)
{
	uint i = 0, pos;
	for(pos = 0; string[pos] != 0; pos++)
	{
		switch(string[pos])
		{
			case '\"' :
			case '\b' :
			case '\f' :
			case '\n' :
			case '\r' :
			case '\t' :
			case '\\' :
			i += 2;
			break;
			default :
			i++;
			break;
		}
	}
	*string_pos += pos + 1;
	return i + 2; 
}

uint assemble_json_string_print(const char *string, char *output, uint *string_pos)
{
	uint i = 0, pos;
	output[i++] = '"';
	for(pos = 0; string[pos] != 0; pos++)
	{
		switch(string[pos])
		{
			case '\"':
			output[i++] = '\\';
			output[i++] = '"';
			break;
			case '\b':
			output[i++] = '\\';
			output[i++] = 'b';
			break;
			case '\f':
			output[i++] = '\\';
			output[i++] = 'f';
			break;
			case '\n':
			output[i++] = '\\';
			output[i++] = 'n';
			break;
			case '\r':
			output[i++] = '\\';
			output[i++] = 'r';
			break;
			case '\t':
			output[i++] = '\\';
			output[i++] = 't';
			break;
			case '\\':
			output[i++] = '\\';
			output[i++] = '\\';
			break;
			default :
			output[i++] = string[pos];
			break;
		}
	}
	output[i++] = '"';
	output[i] = 0;
	if(string_pos != NULL)
		*string_pos += pos + 1;
	return i; 
}


uint assemble_json_messure_value(const char *string, size_t *memory, int *array, AJsonType number_type)
{
	static uint value_allocate = 0;
	uint pos = 1;
	if(string[0] == '{')
	{
		size_t memory_save;
		memory_save = *memory;
		*memory += 1 + sizeof(void *);
		if(*array)
			*memory += sizeof(void *);
		pos = assemble_json_messure_object(&string[1], memory, number_type);
		if(pos == -1)
			return -1;
		return pos + 1;
	}else if(string[0] == '[')
	{	
		uint add;
		int a = TRUE;
		*memory += sizeof(void *) + sizeof(AJasonArrayCount) + 1;
		while(TRUE)
		{	
			if(string[pos] > ' ' && string[pos] != ',')
			{	
				if(string[pos] == ']')
					break;
				a = TRUE;
				add = assemble_json_messure_value(&string[pos], memory, &a, number_type);
				if(add == -1)
					return -1;
				pos += add;
			}else
				pos++;
		}
		if(!a)
			*memory += sizeof(void *);
	//	printf("Array Parse pos %u\n", pos);
		return pos + 1;
	}else if(string[0] == '\"')
	{	
		size_t memory_save;
		uint i;
		memory_save = *memory;
		if(*array)
			i = 1 + sizeof(void *) * 2;
		else
			i = 1 + sizeof(void *) * 1;
		*memory += i;
		i = 1;
		assemble_json_string_parse_size(&string[pos], &pos, &i);
	/*	for(i = 1; string[pos] != '"' && string[pos] != 0; i++)
		{
			if(string[pos] == '\\')
			{
				i++;
				pos++;
			}
			pos++;
		}*/
		if(string[pos] == 0)
		{
#ifdef ASSEMBLE_JSON_ENABLE_PARSE_ERRORS

			printf("JSON: Error: Non terminated string -%s-.\n", string);
#endif
			return -1;
		}
		*memory += i;
	//	printf("Messure String length %u\n", *memory - memory_save); 
		return pos + 1;
	}else if((string[0] >= '0' && string[0] <= '9') || string[0] == '.' || string[0] == '-')
	{
		const uint number_sizes[3] = {sizeof(float) + 1, sizeof(double) + 1, sizeof(int64) + sizeof(uint8) + 1};
		while((string[pos] >= '0' && string[pos] <= '9') || string[pos] == '.')
			pos++;
		*memory += number_sizes[number_type / A_JT_MODULO];
		*array = FALSE;
		return pos;
	}else if(string[0] == 't' && string[1] == 'r' && string[2] == 'u' && string[3] == 'e' && (string[4] <= ' ' || string[4] == ',' || string[4] == ']' || string[4] == '}'))
	{			
		*memory += 1;
		*array = FALSE;
		return 4;
	}else if(string[0] == 'f' && string[1] == 'a' && string[2] == 'l' && string[3] == 's' && string[4] == 'e' && (string[5] <= ' ' || string[5] == ',' || string[5] == ']' || string[5] == '}'))
	{	
		*memory += 1;
		return 5;
	}else if(string[0] == 'n' && string[1] == 'u' && string[2] == 'l' && string[3] == 'l' && (string[4] <= ' ' || string[4] == ',' || string[4] == ']' || string[4] == '}'))
	{	
		*memory += 1;
		*array = FALSE;
		return 4;
	}else
	{
#ifdef ASSEMBLE_JSON_ENABLE_PARSE_ERRORS
		char error[2] = {0, 0};
		error[0] = string[0];
		printf("JSON: Error: Parseing value starting with character '%s'.\n", error);
#endif
		return -1;
	}
}


uint assemble_json_messure_object(const char *string, size_t *memory, AJsonType number_type)
{
	static uint obj_allocate = 0;
	uint i, j;
	int a = FALSE;
	i = 0;
	while(TRUE)
	{
		while(string[i] != 0 && (string[i] <= ' ' || string[i] == ','))
			i++;
		if(string[i] == '\"')
		{
			size_t memory_save;
			memory_save = *memory;
			j = 0;
			i++;
			assemble_json_string_parse_size(&string[i], &i, &j);
			if(string[i] == 0)
			{
#ifdef ASSEMBLE_JSON_ENABLE_PARSE_ERRORS
				printf("JSON: Error: Unexpected end of file after Object name %s \n", &string[i]);
#endif
				return -1;
			}
			i++;				
			*memory += sizeof(void *) * 2 + j;			
			for(; string[i] <= ' ' && string[i] != 0; i++);				
			if(string[i] != ':')
			{
#ifdef ASSEMBLE_JSON_ENABLE_PARSE_ERRORS
				if(string[i] == 0)
				{	
					printf("JSON: Error: Unexpected end of file \n");
					return -1;
				}
				printf("JSON: Error: Expected : \n");
#endif
				return -1;
			}
			i++;
			while(string[i] <= ' ' && string[i] != 0)
				i++;
			if(string[i] == 0)
			{	
#ifdef ASSEMBLE_JSON_ENABLE_PARSE_ERRORS
				printf("JSON: Error: Unexpected end of file\n");
#endif
				return -1;
			}
			a = FALSE;
			j = assemble_json_messure_value(&string[i], memory, &a, number_type);
			i += j;
		}else if(string[i] == '}')		
			return i + 1;
		else
		{
#ifdef ASSEMBLE_JSON_ENABLE_PARSE_ERRORS
			char error_string[2] = {0, 0};
			error_string[0] = string[i];
			printf("JSON: Error: Unexpected character '%s' (%u)\n", error_string, (uint)error_string[0]);
#endif
			return -1;	
		}
	}
	return i + 1;
}

uint assemble_json_parse_value(const char *string, uint8 **memory, int array, AJsonType number_type)
{
	static uint value_allocate = 0;
	uint pos = 1, i;
	unsigned char *value;
	switch(string[0])
	{
		case '{' :
		{
			value = *memory;
			value[0] = A_JT_OBJECT | ASSEMBLE_JSON_WRITE_PROTECTED;
			for(i = 1; i < sizeof(void *) + 1; i++)
				value[i] = 0;
			*memory += 1 + sizeof(void *);
			if(array)
				*memory += sizeof(void *);
			pos = assemble_json_parse_object(&value[1], &string[1], memory, number_type);
		//	printf("assemble_json_parse_object Parse pos %u\n", pos);
			return pos + 1;
		}
		case '[' :
		{	
			unsigned char *v = NULL, *last = NULL;
			uint add, type, category = TRUE;
			AJasonArrayCount count = 0;
			value = *memory;
			value[0] = 0;
			value[1] = 1;
			value[2] = 2;
			value[3] = 3;
			value[4] = 4;
			value[5] = 5;
			value[6] = 6;
			value[7] = 7;
			value[8] = 8;

			value[0] = A_JT_ARRAY | ASSEMBLE_JSON_WRITE_PROTECTED;
			v = &value[1 + sizeof(AJasonArrayCount)];

			*memory += sizeof(void *) + sizeof(AJasonArrayCount) + 1;
			while(TRUE)
			{	
				if(string[pos] > ' ' && string[pos] != ',')
				{	
					if(string[pos] == ']')
						break;
					last = *memory;
					if(v != NULL)
						memcpy(v, &last, sizeof(void *));
					count++;
					add = assemble_json_parse_value(&string[pos], memory, TRUE, number_type);
					if(count == 1)
						type = *last & ASSEMBLE_JSON_CATEGORY_MASK;
					else
						if(type != (*last & ASSEMBLE_JSON_CATEGORY_MASK))
							category = FALSE;
					if(assemble_type_append[*last & ASSEMBLE_JSON_TYPE_MASK])
					{
						last[0] |= ASSEMBLE_JSON_ARRAY | ASSEMBLE_JSON_ARRAY_FOLOW;
						v = NULL;
					}else
					{
						last[0] |= ASSEMBLE_JSON_ARRAY;
						v = &last[assemble_type_size[*last & ASSEMBLE_JSON_TYPE_MASK]];
					}
					pos += add;
				}else
					pos++;
			}
			if(category)
				count += ASSEMBLE_JSON_ARRAY_UNIFORM;
			else
				count += 0;
			memcpy(&value[1], &count, sizeof(AJasonArrayCount));
			if(v == NULL)
			{
				*last &= ~ASSEMBLE_JSON_ARRAY_FOLOW;
				v = *memory;
				*memory += sizeof(void *);
			}
			for(i = 0; i < sizeof(void *); i++)
				v[i] = 0;
		//	printf("Array Parse pos %u\n", pos);
			return pos + 1;
		}
		case '\"' :
		{
			uint8 *value, *next;
			uint i;
			value = *memory;
			value[0] = A_JT_STRING | ASSEMBLE_JSON_WRITE_PROTECTED;
			if(array)
				i = 1 + sizeof(void *) * 2;
			else
				i = 1 + sizeof(void *) * 1;
			next = &value[i];
			memcpy(&value[1], &next, sizeof(void *));
			assemble_json_string_parse(&string[pos], next, &pos, &i);
			*memory += i;
			pos++;
			return pos;
		}		
		case '0' :
		case '1' :
		case '2' :
		case '3' :
		case '4' :
		case '5' :
		case '6' :
		case '7' :	
		case '8' :
		case '9' :
		case '-' :	
		case '.' :	
		{
			if(number_type == A_JT_NUMBER_DECIMAL)
			{				int64 number;
				uint8 decimal;
				value = *memory;
				value[0] = A_JT_NUMBER_DECIMAL | ASSEMBLE_JSON_WRITE_PROTECTED;
				pos = assemble_json_decimal_parce(string, &number, &decimal);
				memcpy(&value[1], &number, sizeof(int64));
				value[1 + sizeof(int64)] = decimal; 
				*memory += sizeof(int64) + 2;
				return pos;
			}else if(number_type == A_JT_NUMBER_FLOAT)
			{

				double d_number;
				float f_number;
				value = *memory;
				pos = assemble_parce_number(string, &d_number);
				f_number = (float)d_number;
				memcpy(&value[1], &f_number, sizeof(float));				
				value[0] = A_JT_NUMBER_FLOAT | ASSEMBLE_JSON_WRITE_PROTECTED;
				*memory += sizeof(float) + 1;
				return pos;
			}else
			{
				double d_number;
				value = *memory;
				pos = assemble_parce_number(string, &d_number);
				memcpy(&value[1], &d_number, sizeof(double));				
				value[0] = A_JT_NUMBER_DOUBLE | ASSEMBLE_JSON_WRITE_PROTECTED;
				*memory += sizeof(double) + 1;
				return pos;
			}
		}
		case 't' :
		{			
			value = *memory;
			value[0] = A_JT_TRUE | ASSEMBLE_JSON_WRITE_PROTECTED;
			*memory += 1;
			return 4;
		}
		case 'f' :
		{	
			value = *memory;
			value[0] = A_JT_FALSE | ASSEMBLE_JSON_WRITE_PROTECTED;
			*memory += 1;
			return 5;
		}
		case 'n' :
		{	
			value = *memory;
			value[0] = A_JT_NULL | ASSEMBLE_JSON_WRITE_PROTECTED;
			*memory += 1;
			return 4;
		}
		break;
	}
	return -1;
}

uint assemble_json_parse_object(unsigned char *link, const char *string, uint8 **memory, AJsonType number_type)
{
	static uint obj_allocate = 0;
	uint i, j;
	i = 0;
	while(TRUE)
	{
		while(string[i] <= ' ' || string[i] == ',')
			i++;
		if(string[i] == '\"')
		{
			memcpy(link, memory, sizeof(void *));
			link = *memory;
			for(j = 0; j < sizeof(void *); j++)
				link[j] = 0;
			i++;
			assemble_json_string_parse(&string[i], &link[j], &i, &j);
		/*	for(; string[i] != '"';)
			{
				if(string[i] == '\\')
					link[j++] = string[i++];
				link[j++] = string[i++];
			}
			link[j++] = 0;*/
			*memory += j;
			
			for(i++; string[i] != ':'; i++);
			i++;
			while(string[i] <= ' ')
				i++;
			j = assemble_json_parse_value(&string[i], memory, FALSE, number_type);
			i += j;
		}else
			return i + 1;
	}
}


void assemble_json_clone_internal(uint8 *to_value, uint8 *from_value)
{
	switch(*from_value & ASSEMBLE_JSON_TYPE_MASK)
	{
		case A_JT_STRING :
		{			
			char *from, *to;
			uint i;
			to_value[0] = A_JT_STRING;
			memcpy(&from, &from_value[1], sizeof(void *));
			for(i = 0; from[i] != 0; i++);
			to = malloc(++i);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
			if(to == NULL)
			{
				printf("JSON: Error: Failed to allocate memory enough for assemble_json_clone\n");
				to_value[0] = A_JT_NULL;
				return;
			}
#endif
			for(i = 0; from[i] != 0; i++)
				to[i] = from[i];
			to[i] = 0;
			memcpy(&to_value[1], &to, sizeof(void *));
		}break;
		case A_JT_NUMBER_FLOAT :
		case A_JT_NUMBER_DOUBLE :
		case A_JT_NUMBER_DECIMAL :
		{	
			const sizes[] = {sizeof(float), sizeof(double), sizeof(int64) + 1};
			memcpy(&to_value[1], &from_value[1], sizes[(to_value[0] = (*from_value & ASSEMBLE_JSON_TYPE_MASK)) / A_JT_MODULO]);
		}
		break;
		case A_JT_OBJECT : 
		{
			uint8 *previous, *from_member, *to_member; 
				uint i;
			to_value[0] = A_JT_OBJECT;
			previous = &to_value[1];
			for(memcpy(&from_member, &from_value[1], sizeof(void *)); from_member != NULL; memcpy(&from_member, from_member, sizeof(void *)))
			{
				for(i = sizeof(void *); from_member[i] != 0; i++);
				i++;
				to_member = malloc(i + assemble_type_size[(from_member[i] & ASSEMBLE_JSON_TYPE_MASK)]);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
				if(to_member == NULL)
				{
					printf("JSON: Error: Failed to allocate memory enough for assemble_json_clone\n");
					break;
				}
#endif
				memcpy(previous, &to_member, sizeof(void *));
				previous = to_member;
				memcpy(&to_member[sizeof(void *)], &from_member[sizeof(void *)], i - sizeof(void *));
				assemble_json_clone_internal(&to_member[i], &from_member[i]);
			}
			for(i = 0; i < sizeof(void *); i++)
				previous[i] = 0;
		}
		break;
		case A_JT_ARRAY :
		{
			uint8 *previous, *from_member, *to_member; 
			uint i, size;
			to_value[0] = A_JT_ARRAY;
			memcpy(&to_value[1], &from_value[1], sizeof(AJasonArrayCount));
			previous = &to_value[1 + sizeof(AJasonArrayCount)];
			for(memcpy(&from_member, &from_value[1 + sizeof(AJasonArrayCount)], sizeof(void *)); from_member != NULL; )
			{
				size = assemble_type_size[(*from_member) & ASSEMBLE_JSON_TYPE_MASK];
				to_member = malloc(size + sizeof(void *));
				memcpy(previous, &to_member, sizeof(void *));
				previous = &to_member[size];
				assemble_json_clone_internal(to_member, from_member);
				to_member[0] |= ASSEMBLE_JSON_ARRAY;
				if(from_member[0] & ASSEMBLE_JSON_ARRAY_FOLOW)
					from_member = &from_member[size];
				else
					memcpy(&from_member, &from_member[size], sizeof(void *));
			}
			for(i = 0; i < sizeof(void *); i++)
				previous[i] = 0;
		}
		break;
		case A_JT_TRUE :
	//	to_value = malloc(1);
		to_value[0] = A_JT_TRUE;
		break;
		case A_JT_FALSE :
	//	to_value = malloc(1);
		to_value[0] = A_JT_FALSE;
		break;
		case A_JT_NULL :
	//	to_value = malloc(1);
		to_value[0] = A_JT_NULL;
		break;
	}
}

uint8 *assemble_json_clone(uint8 *value)
{
	uint8 *to_value;
	to_value = malloc(assemble_type_size[*value & ASSEMBLE_JSON_TYPE_MASK]);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
	if(to_value == NULL)
	{
		printf("JSON: Error: Failed to allocate memory enough for assemble_json_parse\n");
		return NULL;
	}
#endif
	assemble_json_clone_internal(to_value, value);
	return to_value;
}

uint assemble_json_print_size(uint8 *value, uint indentation)
{
	uint i, pos = 0;
	if(value == NULL)
		return 0;
	switch(*value & ASSEMBLE_JSON_TYPE_MASK)
	{
		case A_JT_STRING :
		{
			char *text;
			memcpy(&text, &value[1], sizeof(char *));
			return assemble_json_string_print_size(text, &i);
		}		
		case A_JT_NUMBER_FLOAT :
		{
			float n;
			char number[128];
			memcpy(&n, &value[1], sizeof(float));
			sprintf(number, "%f", n);
			for(i = 0; number[i] != 0; i++);
			for(i--; i > 1 && number[i] == '0'; i--);
			if(number[i] == '.')
			{	
				if(i == 0)
					return 1;
				return i;
			}else
				return i + 1;
		}
		return pos;
		case A_JT_NUMBER_DOUBLE :
		{
			double n;
			char number[128];
			memcpy(&n, &value[1], sizeof(double));
			sprintf(number, "%f", n);
			for(i = 0; number[i] != 0; i++);
			for(i--; i > 1 && number[i] == '0'; i--);
			if(number[i] == '.')
			{	
				if(i == 0)
					return 1;
				return i;
			}else
				return i + 1;
		}
		return pos;
		case A_JT_NUMBER_DECIMAL :
		{
			int64 n;
			memcpy(&n, &value[1], sizeof(int64));
			return assemble_json_decimal_print_size(n, value[1 + sizeof(int64)]);
		}
		return pos;
		case A_JT_OBJECT : 
		{
			uint8 *object;
			pos += 2;
			memcpy(&object, &value[1], sizeof(void *));
			for(; object != NULL;)
			{
				pos += indentation + 1;
				i = sizeof(void *);
				pos += assemble_json_string_print_size(&object[i], &i);
				pos += 3;
				pos += assemble_json_print_size(&object[i], indentation + 1);
				memcpy(&object, object, sizeof(void *));
				if(object != NULL)
				{
					pos += 2;
				}else
					pos += 1;
			}
			pos += indentation;
			pos += 1;
		}
		return pos;
		case A_JT_ARRAY :
		{	
			uint8 *v, *next;
			int type, linebreak = FALSE;
			pos++;			
			memcpy(&v, &value[1 + sizeof(AJasonArrayCount)], sizeof(void *));
			while(v != NULL)
			{
				type = *v & ASSEMBLE_JSON_TYPE_MASK;
				if(type == A_JT_STRING || type == A_JT_OBJECT || type == A_JT_ARRAY)
				{
					linebreak = TRUE;
					break;
				}

				next = &v[assemble_type_size[*v & ASSEMBLE_JSON_TYPE_MASK]];
				if(!(*v & ASSEMBLE_JSON_ARRAY_FOLOW))
					memcpy(&v, next, sizeof(void *));
				else
					v = next;
			}
			if(linebreak)
			{
				indentation++;
				pos += indentation + 1;
			}
			i = 0;
			memcpy(&v, &value[1 + sizeof(AJasonArrayCount)], sizeof(void *));
			while(v != NULL)
			{			
				pos += assemble_json_print_size(v, indentation);
				next = &v[assemble_type_size[*v & ASSEMBLE_JSON_TYPE_MASK]];
				if(!(*v & ASSEMBLE_JSON_ARRAY_FOLOW))
					memcpy(&v, next, sizeof(void *));
				else
					v = next;
				if(v != NULL)
				{
					pos += 2;
					if(linebreak || i % 16 == 15)
						pos += indentation;
				}
				i++;
			}
			if(linebreak)
			{
				pos += indentation;
				indentation--;
			}
			pos++;
		}
		return pos;
		case A_JT_TRUE :
		return 4;
		case A_JT_FALSE :
		return 5;
		case A_JT_NULL :
		return 4;
	}	
	return 0;
}

uint assemble_json_print(char *array, uint8 *value, uint indentation)
{
	uint i, pos = 0;
	if(value == NULL)
		return 0;
	switch(*value & ASSEMBLE_JSON_TYPE_MASK)
	{
		case A_JT_STRING :
		{
			char *text;
			memcpy(&text, &value[1], sizeof(char *));
			pos += assemble_json_string_print(text, &array[pos], &i);
		}
		return pos;
		case A_JT_NUMBER_FLOAT :
		{
			float n;
			char number[128];
			memcpy(&n, &value[1], sizeof(float));
			sprintf(number, "%f", n);
			for(i = 0; number[i] != 0; i++);
			for(i--; i > 1 && number[i] == '0'; i--);
			if(number[i] == '.')
			{	
				if(i == 0)
				{
					array[0] = '0';
					return 1;
				}
				number[i] = 0;
			}else
				number[i + 1] = 0;
			for(i = 0; number[i] != 0; i++)
				array[pos++] = number[i];
		}
		return pos;
		case A_JT_NUMBER_DOUBLE :
		{
			double n;
			char number[128];
			memcpy(&n, &value[1], sizeof(double));
			sprintf(number, "%f", n);
			for(i = 0; number[i] != 0; i++);
			for(i--; i > 1 && number[i] == '0'; i--);
			if(number[i] == '.')
			{	
				if(i == 0)
				{
					array[0] = '0';
					return 1;
				}
				number[i] = 0;
			}else
				number[i + 1] = 0;
			for(i = 0; number[i] != 0; i++)
				array[pos++] = number[i];
		}
		return pos;
		case A_JT_NUMBER_DECIMAL :
		{
			int64 n;
			memcpy(&n, &value[1], sizeof(int64));
			return assemble_json_decimal_print(array, n, value[1 + sizeof(int64)]);				
		}
		case A_JT_OBJECT : 
		{
			uint8 *object;
			array[pos++] = '{';
			array[pos++] = '\n';
			memcpy(&object, &value[1], sizeof(void *));
			for(; object != NULL;)
			{
				for(i = 0; i < indentation + 1; i++)
					array[pos++] = '\t';
				i = sizeof(void *);
				pos += assemble_json_string_print(&object[sizeof(void *)], &array[pos], &i);
				array[pos++] = ' ';
				array[pos++] = ':';
				array[pos++] = ' ';
				array[pos] = 0;
				pos += assemble_json_print(&array[pos], &object[i], indentation + 1);
				memcpy(&object, object, sizeof(void *));
				if(object != NULL)
				{
					array[pos++] = ',';
					array[pos++] = '\n';
				}else
					array[pos++] = '\n';
			}
			for(i = 0; i < indentation; i++)
				array[pos++] = '\t';
			array[pos++] = '}';
		}
		return pos;
		case A_JT_ARRAY :
		{	
			uint8 *v, *next;
			int type, linebreak = FALSE;
			array[pos++] = '[';
			memcpy(&v, &value[1 + sizeof(AJasonArrayCount)], sizeof(void *));
			while(v != NULL)
			{
				type = *v & ASSEMBLE_JSON_TYPE_MASK;
				if(type == A_JT_STRING || type == A_JT_OBJECT || type == A_JT_ARRAY)
				{
					linebreak = TRUE;
					break;
				}

				next = &v[assemble_type_size[*v & ASSEMBLE_JSON_TYPE_MASK]];
				if(!(*v & ASSEMBLE_JSON_ARRAY_FOLOW))
					memcpy(&v, next, sizeof(void *));
				else
					v = next;
			}
			if(linebreak)
			{
				array[pos++] = '\n';
				indentation++;
				for(i = 0; i < indentation; i++)
					array[pos++] = '\t';
			}
			i = 0;
			memcpy(&v, &value[1 + sizeof(AJasonArrayCount)], sizeof(void *));
			while(v != NULL)
			{			
				pos += assemble_json_print(&array[pos], v, indentation);
				next = &v[assemble_type_size[*v & ASSEMBLE_JSON_TYPE_MASK]];
				if(!(*v & ASSEMBLE_JSON_ARRAY_FOLOW))
					memcpy(&v, next, sizeof(void *));
				else
					v = next;
				if(v != NULL)
				{
					if(linebreak || i % 16 == 15)
					{
						array[pos++] = ',';					
						array[pos++] = '\n';
						for(i = 0; i < indentation; i++)
							array[pos++] = '\t';
					}else
					{
						array[pos++] = ',';					
						array[pos++] = ' ';
					}
				}
				i++;
			}
			if(linebreak)
			{
				indentation--;
				array[pos++] = '\n';
				for(i = 0; i < indentation; i++)
					array[pos++] = '\t';
			}
			array[pos++] = ']';
		}
		return pos;
		case A_JT_TRUE :
			array[pos++] = 't';
			array[pos++] = 'r';
			array[pos++] = 'u';
			array[pos++] = 'e';
		return pos;
		case A_JT_FALSE :
			array[pos++] = 'f';
			array[pos++] = 'a';
			array[pos++] = 'l';
			array[pos++] = 's';
			array[pos++] = 'e';
		return pos;
		case A_JT_NULL :
			array[pos++] = 'n';
			array[pos++] = 'u';
			array[pos++] = 'l';
			array[pos++] = 'l';
		return pos;
	}	
	return 0;
}


void assemble_json_free_internal(uint8 *value)
{
	switch(*value & ASSEMBLE_JSON_TYPE_MASK)
	{
		case A_JT_STRING :
		{
			char *string;
			memcpy(&string, &value[1], sizeof(void *));
			free(string);
		}
		break;
		case A_JT_OBJECT : 
		{
			uint8 *object, *next;
			uint i;			
			for(memcpy(&object, &value[1], sizeof(void *)); object != NULL; object = next)
			{
				for(i = sizeof(void *); value[i] != 0; i++);
				assemble_json_free_internal(&value[i + 1]);
				memcpy(&next, object, sizeof(void *));
				free(object);
			}
		}
		break;
		case A_JT_ARRAY :
		{	
			uint8 *v, *next;
			int linebreak = FALSE;
			memcpy(&v, &value[1 + sizeof(AJasonArrayCount)], sizeof(void *));
			while(v != NULL)
			{			
				assemble_json_free_internal(v);
				next = &v[assemble_type_size[*v & ASSEMBLE_JSON_TYPE_MASK]];
				
				if(!(*v & ASSEMBLE_JSON_ARRAY_FOLOW))
				{
					free(v);
					memcpy(&v, next, sizeof(void *));
				}else
				{
					free(v);
					v = next;		
				}
			}
		}
		break;
	}	
}

void assemble_json_free(uint8 *value)
{
	if(*value & ASSEMBLE_JSON_ROOT)
	{
		free(value);
		return;
	}
	if(*value & ASSEMBLE_JSON_WRITE_PROTECTED)
	{
		printf("JSON: Error: Write protected json can only be freed from the root.\n");
		return;
	}
	assemble_json_free_internal(value);
	free(value);
}

char *assemble_json_print_allocate(uint8 *value)
{
	uint size, size2;
	char *array;
	size = assemble_json_print_size(value, 0);
	array = malloc(size + 1);
	size2 = assemble_json_print(array, value, 0);
	if(size2 != size)
		size += 0;
	array[size2] = 0;
	return array;
}

uint8 *assemble_json_parse(char *string, int write_protected, AJsonType number_type)
{
	uint8 *memory, *write,  *output;
	size_t size = 0;
	int a = FALSE;
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
	if(number_type % A_JT_MODULO != A_JT_NUMBER)
	{
		printf("JSON: Error: assemble_json_parse param \"number_type\" is not A_JT_NUMBER_FLOAT, A_JT_NUMBER_DOUBLE or A_JT_NUMBER_DECIMAL.\n");
		return NULL;
	}
#endif
	memory = (uint8 *)NULL;
	while(*string <= ' ')
		string++;
	if(*string != '[' && *string != '{')
		return NULL;
	if(-1 == assemble_json_messure_value(string, &size, &a, number_type))
		return NULL;
	memory = malloc(size);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
	if(memory == NULL)
	{
		printf("JSON: Error: Failed to allocate memory enough for assemble_json_parse\n");
		return NULL;
	}
#endif
	write = memory;
	assemble_json_parse_value(string, &write, FALSE, number_type);
//	f_print_raw(memory, size);
//	size = write - memory;
//	printf("use size %u\n", size);
	memory[0] |= ASSEMBLE_JSON_ROOT;
	if(write_protected)
		return memory;
	output = assemble_json_clone(memory);
	free(memory);
	return output;
}

uint8 *assemble_json_parse_single_pass(char *string, uint string_length, int write_protected, AJsonType number_type)
{
	uint8 *memory, *write,  *output;
	size_t size = 0;
	int a = FALSE;
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
	if(number_type % A_JT_MODULO != A_JT_NUMBER)
	{
		printf("JSON: Error: assemble_json_parse_single_pass param \"number_type\" is not A_JT_NUMBER_FLOAT, A_JT_NUMBER_DOUBLE or A_JT_NUMBER_DECIMAL.\n");
		return NULL;
	}
#endif
	memory = (uint8 *)NULL;
	while(*string <= ' ')
		string++;
	if(*string != '[' && *string != '{')
		return NULL;
	if(assemble_type_size[A_JT_ARRAY] > assemble_type_size[number_type])
		memory = malloc(string_length * assemble_type_size[A_JT_ARRAY] / 2);
	else
		memory = malloc(string_length * assemble_type_size[number_type] / 2);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
	if(memory == NULL)
	{
		printf("JSON: Error: Failed to allocate memory enough for assemble_json_parse_single_pass\n");
		return NULL;
	}
#endif
	write = memory;
	assemble_json_parse_value(string, &write, FALSE, number_type);
	memory[0] |= ASSEMBLE_JSON_ROOT;
	if(write_protected)
		return memory;
	output = assemble_json_clone(memory);
	free(memory);
	return output;
}

uint8 *assemble_json_object_member_get_next(uint8 *object)
{
	uint8 *output;
	memcpy(&output, &object[1], sizeof(void *));
	return output;
}
 
char *assemble_json_object_member_get_name(uint8 *object)
{
	return &object[1 + sizeof(void*)];
} 

uint8 *assemble_json_object_member_search_name_get_member(uint8 *value, char *name, uint type)
{
	uint8 *object, *next;
	uint i;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*value & ASSEMBLE_JSON_TYPE_MASK) != A_JT_OBJECT)
	{
		printf("JSON: Error: Trying to call assemble_json_object_member_search_name_get_member on value not containing a object \n");
		return NULL;
	}
#endif
	if(type != -1)
		type %= A_JT_MODULO;
	for(memcpy(&object, &value[1], sizeof(void *)); object != NULL; object = next)
	{
		next = object;
		object += sizeof(void *);
		for(i = 0; name[i] == object[i]; i++)
		{
			if(name[i] == 0)
			{
				if(type == -1 || type == (object[i + 1] & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO)
					return next;
				else
					break;
			}
		}
		memcpy(&next, next, sizeof(void *));		
	}
	return NULL;
}

uint8 *assemble_json_object_member_search_name_get_value(uint8 *value, char *name, uint type)
{
	uint8 *member, *next;
	uint i;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*value & ASSEMBLE_JSON_TYPE_MASK) != A_JT_OBJECT)
	{
		printf("JSON: Error: Trying to call assemble_json_object_member_search_name_get_member on value not containing a object \n");
		return NULL;
	}
#endif
	if(type != -1)
		type %= A_JT_MODULO;
	for(memcpy(&member, &value[1], sizeof(void *)); member != NULL; member = next)
	{
		next = member;
		member += sizeof(void *);
		for(i = 0; name[i] == member[i]; i++)
		{
			if(name[i] == 0)
			{
				if(type == -1 || type == (member[i + 1] & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO)
					return &member[i + 1];
				else
					break;
			}
		}
		memcpy(&next, next, sizeof(void *));
	}
	return NULL;
} 

char *assemble_json_object_member_search_name_get_string(uint8 *value, char *name)
{
	char *string;
	value = assemble_json_object_member_search_name_get_value(value, name, A_JT_STRING);
	if(value == NULL)
		return NULL;
	memcpy(&string, &value[1], sizeof(void *));
	return string;
}

int assemble_json_object_member_search_name_enum_test(uint8 *value, char *name, char **enum_names, uint enum_count, uint *output)
{
	char *string;
	uint i, j;
	value = assemble_json_object_member_search_name_get_value(value, name, A_JT_STRING);
	if(value == NULL)
		return FALSE;
	memcpy(&string, &value[1], sizeof(void *));
	for(i = 0; i < enum_count; i++)
	{
		name = enum_names[i];
		for(j = 0; string[j] != 0 && string[j] == name[j]; j++);
		if(string[j] == name[j])
		{
			*output = i;
			return TRUE;
		}
	}
	return FALSE;
}


size_t assemble_json_object_member_search_name_get_string_copy(uint8 *value, char *name, char *buffer, size_t buffer_size)
{
	char *string;
	size_t length;
	value = assemble_json_object_member_search_name_get_value(value, name, A_JT_STRING);
	if(value == NULL)
		return 0;
	memcpy(&string, &value[1], sizeof(void *));
	length = strlen(string);
	if(length < buffer_size)
	{
		memcpy(buffer, string, length + 1);
		return length;
	}else
	{
		memcpy(buffer, string, --buffer_size);
		buffer[buffer_size] = 0;
		return buffer_size;
	}
}

float assemble_json_object_member_search_name_get_float(uint8 *value, char *name, float default_value)
{
	uint type;
	value = assemble_json_object_member_search_name_get_value(value, name, A_JT_NUMBER);
	if(value == NULL)
		return default_value;
	return assemble_json_value_number_get_float(value);
}

double assemble_json_object_member_search_name_get_double(uint8 *value, char *name, float default_value)
{
	value = assemble_json_object_member_search_name_get_value(value, name, A_JT_NUMBER);
	if(value == NULL)
		return default_value;
	return assemble_json_value_number_get_double(value);
}

void assemble_json_object_member_search_name_get_decimal(uint8 *value, char *name, AJsonDecimalNumber *decimal)
{
	value = assemble_json_object_member_search_name_get_value(value, name, A_JT_NUMBER);
	if(value == NULL)
		return;
	assemble_json_value_number_get_decimal(value, decimal);
}

int64 assemble_json_object_member_search_name_get_integer(uint8 *value, char *name, int64 default_value)
{
	value = assemble_json_object_member_search_name_get_value(value, name, A_JT_NUMBER);
	if(value == NULL)
		return default_value;
	return assemble_json_value_number_get_integer(value);
}
int assemble_json_object_member_search_name_get_boolean(uint8 *value, char *name, int default_value)
{
	value = assemble_json_object_member_search_name_get_value(value, name, A_JT_BOOLEAN);
	if(value == NULL)
		return default_value;
	return value[0] == A_JT_TRUE;
}

uint8 *assemble_json_object_member_search_name_detach_value(uint8 *value, char *name, uint type)
{
	uint8 *object, *next, *last, *copy;
	uint i;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*value & ASSEMBLE_JSON_TYPE_MASK) != A_JT_OBJECT)
	{
		printf("JSON: Error: Trying to call assemble_json_object_member_search_name_detach_value on value not containing a object \n");
		return NULL;
	}
#endif
	memcpy(&last, &value[1], sizeof(void *));
	if(type != -1)
		type %= A_JT_MODULO;
	for(object = last; object != NULL; object = next)
	{
		next = object;
		object += sizeof(void *);
		for(i = 0; name[i] == object[i]; i++)
		{
			if(name[i] == 0)
			{	
				object = &object[i + 1];
				if(type == -1 || type == (*object & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO)
				{
					copy = malloc(assemble_type_size[*object]);
					memcpy(copy, object, assemble_type_size[*object]);
					memcpy(last, next, sizeof(void *));
					free(next);					
					return copy;
				}
				else
					break;
			}
		}
		last = next;
		memcpy(&next, next, sizeof(void *));
	}
	return NULL;
} 

int assemble_json_object_member_search_name_delete_value(uint8 *value, char *name, uint type)
{
	uint8 *object, *next, *last;
	uint i;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*value & ASSEMBLE_JSON_TYPE_MASK) != A_JT_OBJECT)
	{
		printf("JSON: Error: Trying to call assemble_json_object_member_search_name_detach_value on value not containing a object \n");
		return FALSE;
	}
	if(*value & ASSEMBLE_JSON_WRITE_PROTECTED)
	{
		printf("JSON: Error: Write protected json can only be freed from the root.\n");
		return FALSE;
	}
#endif
	memcpy(&last, &value[1], sizeof(void *));
	if(type != -1)
		type %= A_JT_MODULO;
	for(object = last; object != NULL; object = next)
	{
		next = object;
		object += sizeof(void *);
		for(i = 0; name[i] == object[i]; i++)
		{
			if(name[i] == 0)
			{	
				object = &object[i + 1];
				if(type == -1 || type == (*object & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO)
				{
					assemble_json_free_internal(object);
					memcpy(last, next, sizeof(void *));
					free(next);							
					return TRUE;
				}
				else
					break;
			}
		}
		last = next;
		memcpy(&next, next, sizeof(void *));
	}
	return FALSE;
} 

uint8 *assemble_json_object_member_get_value(uint8 *object)
{
	object += sizeof(void *);
	while(*object != 0)
		object++;
	object++;
	return object;
}

AJsonType assemble_json_value_type_get(uint8 *value)
{
	return *value & ASSEMBLE_JSON_TYPE_MASK;
}

char *assemble_json_value_string_get(uint8 *value)
{
	char *string;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*value & ASSEMBLE_JSON_TYPE_MASK) != A_JT_STRING)
	{
		printf("JSON: Error: Trying to call assemble_json_value_string_get on value not containing a string \n");
		return NULL;
	}
#endif
	memcpy(&string, &value[1], sizeof(void *));
	return string;
}

uint assemble_json_value_string_set(uint8 *value, char *string)
{
	char *buffer;
	uint i;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*value & ASSEMBLE_JSON_TYPE_MASK) != A_JT_STRING)
	{
		printf("JSON: Error: Trying to call assemble_json_value_string_set on value not containing a string \n");
		return FALSE;
	}
	if(*value & ASSEMBLE_JSON_WRITE_PROTECTED)
	{
		printf("JSON: Error: Trying to call assemble_json_value_string_set on write protected value.\n");
		return FALSE;
	}
	if(string == NULL)
	{
		printf("JSON: Error: Trying to call assemble_json_value_string_set with a NULL string parameter.\n");
		return FALSE;
	}
#endif
	memcpy(&buffer, &value[1], sizeof(void *));
	free(buffer);
	for(i = 0; string[i] != 0; i++);
	buffer = malloc(++i);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
	if(buffer == NULL)
	{
		printf("JSON: Error: Failed to allocate memory enough for assemble_json_value_string_set\n");
		return FALSE;
	}
#endif
	for(i = 0; string[i] != 0; i++)
		buffer[i] = string[i];
	buffer[i] = 0;
	memcpy(&value[1], &buffer, sizeof(void *));
	return TRUE;
}


float assemble_json_value_number_get_float(uint8 *value)
{
	uint type;
	type = *value & ASSEMBLE_JSON_TYPE_MASK;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if(type % A_JT_MODULO != A_JT_NUMBER)
	{
		printf("JSON: Error: Trying to call assemble_json_value_number_get on value not containing a number \n");
		return 0;
	}
#endif
	if(type == A_JT_NUMBER_FLOAT)
	{
		float number;
		memcpy(&number, &value[1], sizeof(float));
		return (float)number;
	}else if(type == A_JT_NUMBER_DOUBLE)
	{
		double number;
		memcpy(&number, &value[1], sizeof(double));
		return (float)number;
	}else
	{
		int64 integet;
		memcpy(&integet, &value[1], sizeof(int64));
		return (float)integet * assemble_float_decimal_lookup_table[value[1 + sizeof(int64)]];
	}
}

uint assemble_json_value_number_set_float(uint8 *value, float number)
{
	uint type;
	type = *value & ASSEMBLE_JSON_TYPE_MASK;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if(type % A_JT_MODULO != A_JT_NUMBER)
	{
		printf("JSON: Error: Trying to call assemble_json_value_number_set_double on value not containing a number \n");
		return FALSE;
	}
#endif
	if(type == A_JT_NUMBER_FLOAT)
	{
		memcpy(&value[1], &number, sizeof(float));
	}else if(type == A_JT_NUMBER_DOUBLE)
	{
		double numberd;
		numberd = (double)number;
		memcpy(&value[1], &numberd, sizeof(double));
	}else
	{
		char buffer[64];
		int64 real_output;
		uint8 decimal;
		sprintf(buffer, "%f", number);
		assemble_json_decimal_parce(buffer, &real_output, &decimal);
		memcpy(&value[1], &real_output, sizeof(int64));
		value[1 + sizeof(int64)] = decimal;
	}
	return TRUE;
}

double assemble_json_value_number_get_double(uint8 *value)
{
	uint type;
	type = *value & ASSEMBLE_JSON_TYPE_MASK;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if(type % A_JT_MODULO != A_JT_NUMBER)
	{
		printf("JSON: Error: Trying to call assemble_json_value_number_get on value not containing a number \n");
		return 0;
	}
#endif
	if(type == A_JT_NUMBER_FLOAT)
	{
		float number;
		memcpy(&number, &value[1], sizeof(float));
		return (double)number;
	}else if(type == A_JT_NUMBER_DOUBLE)
	{
		double number;
		memcpy(&number, &value[1], sizeof(double));
		return number;
	}else
	{
		int64 integet;
		memcpy(&integet, &value[1], sizeof(int64));
		return (double)integet * assemble_double_decimal_lookup_table[value[1 + sizeof(int64)]];
	}
}

uint assemble_json_value_number_set_double(uint8 *value, double number)
{
	uint type;
	type = *value & ASSEMBLE_JSON_TYPE_MASK;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if(type % A_JT_MODULO != A_JT_NUMBER)
	{
		printf("JSON: Error: Trying to call assemble_json_value_number_set_double on value not containing a number \n");
		return FALSE;
	}
#endif
	if(type == A_JT_NUMBER_FLOAT)
	{
		float numberf;
		numberf = (float)number;
		memcpy(&value[1], &number, sizeof(float));
	}else if(type == A_JT_NUMBER_DOUBLE)
	{
		memcpy(&value[1], &number, sizeof(double));
	}else
	{
		char buffer[64];
		int64 real_output;
		uint8 decimal;
		sprintf(buffer, "%f", number);
		assemble_json_decimal_parce(buffer, &real_output, &decimal);
		memcpy(&value[1], &real_output, sizeof(int64));
		value[1 + sizeof(int64)] = decimal;
	}
	return TRUE;
}

void assemble_json_value_number_get_decimal(uint8 *value, AJsonDecimalNumber *decimal)
{
	uint type;
	type = *value & ASSEMBLE_JSON_TYPE_MASK;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if(type % A_JT_MODULO != A_JT_NUMBER)
	{
		printf("JSON: Error: Trying to call assemble_json_value_number_get on value not containing a number \n");
		return;
	}
#endif
	if(type == A_JT_NUMBER_FLOAT)
	{
		char buffer[64];
		float number;
		memcpy(&number, &value[1], sizeof(float));
		sprintf(buffer, "%f", number);
		assemble_json_decimal_parce(buffer, &decimal->integer, &decimal->decimal);
	}else if(type == A_JT_NUMBER_DOUBLE)
	{
		char buffer[64];
		double number;
		memcpy(&number, &value[1], sizeof(double));
		sprintf(buffer, "%f", number);
		assemble_json_decimal_parce(buffer, &decimal->integer, &decimal->decimal);
	}else
	{
		int64 integet;
		memcpy(&decimal->integer, &value[1], sizeof(int64));
		decimal->decimal = value[1 + sizeof(int64)];
	}
}


int64 assemble_json_value_number_get_integer(uint8 *value)
{
	uint type;
	type = *value & ASSEMBLE_JSON_TYPE_MASK;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if(type % A_JT_MODULO != A_JT_NUMBER)
	{
		printf("JSON: Error: Trying to call assemble_json_value_number_get_integer on value not containing a number \n");
		return;
	}
#endif
	if(type == A_JT_NUMBER_FLOAT)
	{
		float number;
		memcpy(&number, &value[1], sizeof(float));
		return (int64)number;
	}else if(type == A_JT_NUMBER_DOUBLE)
	{
		double number;
		memcpy(&number, &value[1], sizeof(double));
		return (int64)number;
	}else
	{
		AJsonDecimalNumber decimal;
		uint i;
		memcpy(&decimal.integer, &value[1], sizeof(int64));
		decimal.decimal = value[1 + sizeof(int64)];
		for(i = 0; i < decimal.decimal; i++)
			decimal.integer /= 10;
		return decimal.integer;

	}
}

uint assemble_json_value_number_set_decimal(uint8 *value, AJsonDecimalNumber *decimal)
{
	uint type;
	type = *value & ASSEMBLE_JSON_TYPE_MASK;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if(type % A_JT_NUMBER != A_JT_NUMBER)
	{
		printf("JSON: Error: Trying to call assemble_json_value_number_set_double on value not containing a number \n");
		return FALSE;
	}
#endif
	if(type == A_JT_NUMBER_FLOAT)
	{
		float number;
		number = (float)decimal->integer * assemble_float_decimal_lookup_table[decimal->decimal];
		memcpy(&value[1], &number, sizeof(float));
	}else if(type == A_JT_NUMBER_DOUBLE)
	{
		double number;
		number = (double)decimal->integer * assemble_double_decimal_lookup_table[decimal->decimal];
		memcpy(&value[1], &number, sizeof(double));
	}else
	{
		memcpy(&value[1], &decimal->integer, sizeof(int64));
		value[1 + sizeof(int64)] = decimal->decimal;
	}
	return TRUE;
}


uint8 *assemble_json_object_member_get_first(uint8 *value)
{
	void *pointer;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*value & ASSEMBLE_JSON_TYPE_MASK) != A_JT_OBJECT)
	{
		printf("JSON: Error: Trying to call assemble_json_object_member_get_first on value not containing a object \n");
		return NULL;
	}
#endif
	memcpy(&pointer, &value[1], sizeof(void *));
	return pointer;
}

AJasonArrayCount assemble_json_value_array_get_length(uint8 *value)
{
	AJasonArrayCount count;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*value & ASSEMBLE_JSON_TYPE_MASK) != A_JT_ARRAY)
	{
		printf("JSON: Error: Trying to call assemble_json_value_array_get_length on value not containing a array\n");
		return 0;
	}
#endif
	memcpy(&count, &value[1], sizeof(AJasonArrayCount));
	return count & ~ASSEMBLE_JSON_ARRAY_UNIFORM;
}

int assemble_json_value_array_first_get_uniform(uint8 *value)
{
	AJasonArrayCount count;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*value & ASSEMBLE_JSON_TYPE_MASK) != A_JT_ARRAY)
	{
		printf("JSON: Error: Trying to call assemble_json_value_array_first_get_uniform on value not containing a array\n");
		return FALSE;
	}
#endif
	memcpy(&count, &value[1], sizeof(AJasonArrayCount));
	if(count & ASSEMBLE_JSON_ARRAY_UNIFORM)
		return TRUE;
	else
		return FALSE;
}


int assemble_json_value_array_first_get_uniform_type(uint8 *value)
{
	AJasonArrayCount count;
	uint8 *first;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*value & ASSEMBLE_JSON_TYPE_MASK) != A_JT_ARRAY)
	{
		printf("JSON: Error: Trying to call assemble_json_value_array_first_get_uniform_type on value not containing a array\n");
		return 0;
	}
#endif
	memcpy(&count, &value[1], sizeof(AJasonArrayCount));
	if(count & ASSEMBLE_JSON_ARRAY_UNIFORM)
	{
		memcpy(&first, &value[1 + sizeof(AJasonArrayCount)], sizeof(void *));
		return (first[0] & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO;
	}else
		return -1;
}


uint8 *assemble_json_value_array_first_get(uint8 *value)
{
	void *pointer;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*value & ASSEMBLE_JSON_TYPE_MASK) != A_JT_ARRAY)
	{
		printf("JSON: Error: Trying to call assemble_json_value_array_first_get on value not containing a array\n");
		return NULL;
	}
#endif
	memcpy(&pointer, &value[1 + sizeof(AJasonArrayCount)], sizeof(void *));
	return pointer;
}


AJsonType assemble_json_value_get_is_array_member(uint8 *value)
{
	if(*value & ASSEMBLE_JSON_ARRAY)
		return A_JT_TRUE;
	return A_JT_FALSE;
}

uint8 *assemble_json_value_get_next(uint8 *value)
{
	void *pointer;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if(!(*value & ASSEMBLE_JSON_ARRAY))
	{
		printf("JSON: Error: Trying to call assemble_json_value_get_next on a value not that is not part of an array \n");
		return NULL;
	}
#endif
	pointer = &value[assemble_type_size[*value & ASSEMBLE_JSON_TYPE_MASK]];
	if(!(*value & ASSEMBLE_JSON_ARRAY_FOLOW))
		memcpy(&pointer, pointer, sizeof(void *));
	return pointer;

}

void assemble_json_value_set_true_false(uint8 *value, int boolean_value)
{
	uint type;
	type = *value & ASSEMBLE_JSON_TYPE_MASK;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if(type % A_JT_MODULO != A_JT_BOOLEAN)
	{	
		printf("JSON: Error: Trying to call assemble_json_value_set_true on a value not that is not ether A_JT_TRUE or A_JT_FALSE \n");
		return;
	}
#endif
	*value &= ~ASSEMBLE_JSON_TYPE_MASK;
	if(boolean_value)
		*value |= A_JT_TRUE;
	else
		*value |= A_JT_FALSE;
}

uint8 *assemble_json_value_allcoate(AJsonType type, double number, char *string)
{	
	uint8 *value;
	value = malloc(assemble_type_size[type]);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
	if(value == NULL)
	{
		printf("JSON: Error: Failed to allocate memory enough for assemble_json_value_allcoate\n");
		return NULL;
	}
#endif
	*value = type;
	switch(type % ASSEMBLE_JSON_TYPE_MASK)
	{
		case A_JT_STRING :
		{
			char *copy;
			uint i;
			for(i = 0; string[i] != 0; i++);
			copy = malloc(i + 1);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
			if(copy == NULL)
			{
				printf("JSON: Error: Failed to allocate memory enough for assemble_json_value_allcoate\n");
				free(value);
				return NULL;
			}
#endif
			for(i = 0; string[i] != 0; i++)
				copy[i] = string[i];
			copy[i] = 0;
			memcpy(&value[1], &copy, sizeof(void *));
			return value;
		}
		return value;
		case A_JT_NUMBER_FLOAT :
		{
			float n;
			n = (float)number;
			memcpy(&value[1], &n, sizeof(float));
		}
		return value;
		case A_JT_NUMBER_DOUBLE :
		{
			memcpy(&value[1], &number, sizeof(double));
		}
		return value;
		case A_JT_NUMBER_DECIMAL :
		{
			char buffer[64];
			int64 real_output;
			uint8 decimal;
			sprintf(buffer, "%f", number);
			assemble_json_decimal_parce(buffer, &real_output, &decimal);
			memcpy(&value[1], &real_output, sizeof(int64));
			value[1 + sizeof(int64)] = decimal;
		}
		return value;
		case A_JT_OBJECT :
		{
			uint i;
			for(i = 1; i < 1 + sizeof(void *); i++)
				value[i] = 0;
			return value;
		}
		case A_JT_ARRAY :
		{
			uint i;
			for(i = 1; i < 1 + sizeof(void *) + sizeof(AJasonArrayCount); i++)
				value[i] = 0;
			return value;
		}
		default :
		return value;
	}
}

uint8 *assemble_json_object_member_add(uint8 *object, uint8 *value, char *name)
{
	uint8 *member, *m;
	uint i;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((object[0] & ASSEMBLE_JSON_TYPE_MASK) != A_JT_OBJECT)
	{	
		printf("JSON: Error: Trying to call assemble_json_object_member_add on a value not that is not of type A_JT_OBJECT\n");
		return NULL;
	}
	if(object[0] & ASSEMBLE_JSON_WRITE_PROTECTED)
	{	
		printf("JSON: Error: Trying to call assemble_json_object_member_add on a object that is write protected\n");
		return NULL;
	}	
	if(object[0] & ASSEMBLE_JSON_WRITE_PROTECTED)
	{	
		printf("JSON: Error: Trying to call assemble_json_object_member_add on a value that is write protected\n");
		return NULL;
	}
#endif
	for(i = 0; name[i] != 0; i++);
	member = malloc(sizeof(void *) + i + 1 + assemble_type_size[value[0] & ASSEMBLE_JSON_TYPE_MASK]);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
	if(member == NULL)
	{
		printf("JSON: Error: assemble_json_object_member_add failed to allocate memory\n");
		return NULL;
	}
#endif
	m = &member[sizeof(void *)];
	for(i = 0; name[i] != 0; i++)
		m[i] = name[i];
	m[i++] = 0;
	memcpy(&m[i], value, assemble_type_size[value[0] & ASSEMBLE_JSON_TYPE_MASK]);
	free(value);
	memcpy(&member[0], &object[1], sizeof(void *));
	memcpy(&object[1], &member, sizeof(void *));
	return &m[i];
}

uint8 *assemble_json_object_member_add_create(uint8 *object, char *name, AJsonType type, void *data)
{
	uint8 *member, *m;
	uint i;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((object[0] & ASSEMBLE_JSON_TYPE_MASK) != A_JT_OBJECT)
	{	
		printf("JSON: Error: Trying to call assemble_json_object_member_add_create on a value not that is not of type A_JT_OBJECT\n");
		return NULL;
	}
	if(object[0] & ASSEMBLE_JSON_WRITE_PROTECTED)
	{	
		printf("JSON: Error: Trying to call assemble_json_object_member_add_create on a object that is write protected\n");
		return NULL;
	}	
	if(object[0] & ASSEMBLE_JSON_WRITE_PROTECTED)
	{	
		printf("JSON: Error: Trying to call assemble_json_object_member_add_create on a value that is write protected\n");
		return NULL;
	}
#endif
	if(type % A_JT_MODULO != A_JT_BOOLEAN && type % A_JT_MODULO != A_JT_OBJECT && type % A_JT_MODULO != A_JT_ARRAY && data == NULL)
		type = A_JT_NULL;
	for(i = 0; name[i] != 0; i++);
	member = malloc(sizeof(void *) + i + 1 + assemble_type_size[type]);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
	if(member == NULL)
	{
		printf("JSON: Error: assemble_json_object_member_add_create failed to allocate memory\n");
		return NULL;
	}
#endif
	m = &member[sizeof(void *)];
	for(i = 0; name[i] != 0; i++)
		m[i] = name[i];
	m[i++] = 0;
	m = &m[i];
	*m = type;
	switch(type)
	{
		case A_JT_STRING :
		{
			char *copy, *string;
			string = data;
			for(i = 0; string[i] != 0; i++);
			copy = malloc(i + 1);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
			if(copy == NULL)
			{
				printf("JSON: Error: assemble_json_object_member_add_create failed to allocate memory\n");
				free(copy);
				free(member);
				return NULL;
			}
#endif
			for(i = 0; string[i] != 0; i++)
				copy[i] = string[i];
			copy[i] = 0;
			memcpy(&m[1], &copy, sizeof(void *));
		}
		break;
		case A_JT_NUMBER_FLOAT :
		{
			memcpy(&m[1], data, sizeof(float));
		}
		break;
		case A_JT_NUMBER_DOUBLE :
		{
			memcpy(&m[1], data, sizeof(double));
		}
		break;
		case A_JT_NUMBER_DECIMAL :
		{
			f_debug_memory();
			memcpy(&m[1], &((AJsonDecimalNumber *)data)->integer, sizeof(int64));
			f_debug_memory();
			m[1 + sizeof(int64)] = ((AJsonDecimalNumber *)data)->decimal;
			f_debug_memory();
		}
		break;
		case A_JT_OBJECT :
			if(data != NULL)
			{
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
				if((((uint8 *)data)[0] & ASSEMBLE_JSON_TYPE_MASK) != A_JT_OBJECT)
				{	
					printf("JSON: Error: Trying to call assemble_json_object_member_add_create with \"type\" set to A_JT_OBJECT, but the \"data\" param is not a pointer to a object.\n");
					return NULL;
				}
#endif
				memcpy(&m[1], &((uint8 *)data)[1], sizeof(void *));
				free(data);
			}else
			{
				for(i = 1; i < sizeof(void *) + 1; i++)
					m[i] = 0;
			}
		break;	
		case A_JT_ARRAY :
			if(data != NULL)
			{
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
				if((((uint8 *)data)[0] & ASSEMBLE_JSON_TYPE_MASK) != A_JT_ARRAY)
				{	
					printf("JSON: Error: Trying to call assemble_json_object_member_add_create with \"type\" set to A_JT_ARRAY, but the \"data\" param is not a pointer to an array.\n");
					return NULL;
				}
#endif
				memcpy(&m[1], &((uint8 *)data)[1], sizeof(void *) + sizeof(AJasonArrayCount));
				free(data);
			}else
			{
				for(i = 1; i < sizeof(void *) + sizeof(AJasonArrayCount) + 1; i++)
					m[i] = 0;
			}
		break;	
	}
	memcpy(&member[0], &object[1], sizeof(void *));
	memcpy(&object[1], &member, sizeof(void *));
	return m;
}

uint8 *assemble_json_object_member_add_boolean_create(uint8 *object, char *name, int boolean_value)
{
	if(boolean_value)
		return assemble_json_object_member_add_create(object, name, A_JT_TRUE, NULL);
	else
		return assemble_json_object_member_add_create(object, name, A_JT_FALSE, NULL);
}

uint8 *assemble_json_object_member_add_float_create(uint8 *object, char *name, float value)
{
	return assemble_json_object_member_add_create(object, name, A_JT_NUMBER_FLOAT, &value);
}

uint8 *assemble_json_object_member_add_double_create(uint8 *object, char *name, double value)
{
	return assemble_json_object_member_add_create(object, name, A_JT_NUMBER_DOUBLE, &value);
}

uint8 *assemble_json_object_member_add_decimal_create(uint8 *object, char *name, int64 integer, uint8 decimal)
{
	AJsonDecimalNumber value;
	value.integer = integer;
	value.decimal = decimal; 
	return assemble_json_object_member_add_create(object, name, A_JT_NUMBER_DECIMAL, &value);
}



uint8 *assemble_json_value_array_add(uint8 *array, uint8 *insert, uint8 *after)
{
	AJasonArrayCount count;
 	uint8 *member, *compare;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*array & ASSEMBLE_JSON_TYPE_MASK) != A_JT_ARRAY)
	{	
		printf("JSON: Error: Trying to call assemble_json_value_array_add on a value not that is not of type A_JT_ARRAY\n");
		return NULL;
	}
	if(*array & ASSEMBLE_JSON_WRITE_PROTECTED)
	{	
		printf("JSON: Error: Trying to call assemble_json_value_array_add on a object that is write protected\n");
		return NULL;
	}	
	if(*insert & ASSEMBLE_JSON_WRITE_PROTECTED)
	{	
		printf("JSON: Error: Trying to call assemble_json_value_array_add on a value that is write protected\n");
		return NULL;
	}
#endif
	member = malloc(assemble_type_size[*insert] + sizeof(void *));
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
	if(member == NULL)
	{
		printf("JSON: Error: assemble_json_value_array_add failed to allocate memory\n");
		return NULL;
	}		
#endif
	memcpy(&count, &array[1], sizeof(AJasonArrayCount));
	count++;
	if(after != NULL)
	{
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
		if(*after & ASSEMBLE_JSON_WRITE_PROTECTED)
		{	
			printf("JSON: Error: Trying to call assemble_json_value_array_add on a \"after\" value that is write protected\n");
			return NULL;
		}
		if(!(*after & ASSEMBLE_JSON_ARRAY))
		{	
			printf("JSON: Error: Trying to call assemble_json_value_array_add on a \"after\" value that is not an element of an array\n");
			return NULL;
		}
#endif	
		if(count == 1)
			count += ASSEMBLE_JSON_ARRAY_UNIFORM; // if this is the first member, make it uniform
		else if((insert[0] & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO != (after[0] & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO)			
			count %= ASSEMBLE_JSON_ARRAY_UNIFORM; // if this is not the same type as the last one, make it un-uniform
		memcpy(member, insert, assemble_type_size[*insert]);
		memcpy(&member[assemble_type_size[(*member & ASSEMBLE_JSON_TYPE_MASK)]], &after[assemble_type_size[(*after & ASSEMBLE_JSON_TYPE_MASK)]], sizeof(void *));
		memcpy(&after[assemble_type_size[(*after & ASSEMBLE_JSON_TYPE_MASK)]], &member, sizeof(void *));
		free(insert);
	}else
	{
		if(count == 1)
			count += ASSEMBLE_JSON_ARRAY_UNIFORM; // if this is the first member, make it uniform
		else if(count & ASSEMBLE_JSON_ARRAY_UNIFORM)
		{
			memcpy(&compare, &array[1 + sizeof(AJasonArrayCount)], sizeof(void *));
			if(compare != NULL && (insert[0] & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO != (compare[0] & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO)			
				count %= ASSEMBLE_JSON_ARRAY_UNIFORM; // if this is not the same type as the last one, make it un-uniform
		}

		memcpy(member, insert, assemble_type_size[(insert[0] & ASSEMBLE_JSON_TYPE_MASK)]);
		memcpy(&member[assemble_type_size[(insert[0] & ASSEMBLE_JSON_TYPE_MASK)]], &array[1 + sizeof(AJasonArrayCount)], sizeof(void *));
		memcpy(&array[1 + sizeof(AJasonArrayCount)], &member, sizeof(void *));
		free(insert);
	}
	member[0] |= ASSEMBLE_JSON_ARRAY;
	memcpy(&array[1], &count, sizeof(AJasonArrayCount));
	return member;
}

uint8 *assemble_json_value_array_add_to_create(uint8 *array, uint8 *after, AJsonType type, void *data)
{
	uint8 *member, *compare;
	AJasonArrayCount count;
	uint i;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*array & ASSEMBLE_JSON_TYPE_MASK) != A_JT_ARRAY)
	{	
		printf("JSON: Error: Trying to call assemble_json_value_array_add_to_create on a value not that is not of type A_JT_OBJECT\n");
		return NULL;
	}
	if(*array & ASSEMBLE_JSON_WRITE_PROTECTED)
	{	
		printf("JSON: Error: Trying to call assemble_json_value_array_add_to_create on a object that is write protected\n");
		return NULL;
	}	
#endif
	member = malloc(assemble_type_size[type] + sizeof(void *));
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
	if(member == NULL)
	{
		printf("JSON: Error: assemble_json_value_array_add_to_create failed to allocate memory\n");
		free(member);
		return NULL;
	}		
#endif

	member[0] = type;
	switch(type)
	{
		case A_JT_STRING :
		{
			char *copy, *string;
			string = data;
			for(i = 0; string[i] != 0; i++);
			copy = malloc(i + 1);
#ifdef ASSEMBLE_JSON_ENABLE_RUNTIME_ERRORS
			if(copy == NULL)
			{
				printf("JSON: Error: assemble_json_value_array_add_to_create failed to allocate memory\n");
				free(copy);
				free(member);
				return NULL;
			}
#endif
			for(i = 0; string[i] != 0; i++)
				copy[i] = string[i];
			copy[i] = 0;
			memcpy(&member[1], &copy, sizeof(void *));
		}
		break;
		case A_JT_NUMBER_FLOAT :
		{
			memcpy(&member[1], data, sizeof(float));
		}
		break;
		case A_JT_NUMBER_DOUBLE :
		{
			memcpy(&member[1], data, sizeof(double));
		}
		break;
		case A_JT_NUMBER_DECIMAL :
		{
			memcpy(&member[1], &((AJsonDecimalNumber *)data)->integer, sizeof(int64));
			member[1 + sizeof(int64)] = ((AJsonDecimalNumber *)data)->decimal;
		}
		break;
		case A_JT_OBJECT :
			if(data != NULL)
			{
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
				if((((uint8 *)data)[0] & ASSEMBLE_JSON_TYPE_MASK) != A_JT_OBJECT)
				{	
					printf("JSON: Error: Trying to call assemble_json_value_array_add_to_create with \"type\" set to A_JT_OBJECT, but the \"data\" param is not a pointer to a object.\n");
					return NULL;
				}
#endif
				memcpy(&member[1], &((uint8 *)data)[1], sizeof(void *));
				free(data);
			}else
			{
				for(i = 1; i < sizeof(void *) + 1; i++)
					member[i] = 0;
			}
		break;	
		case A_JT_ARRAY :
			if(data != NULL)
			{
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
				if((((uint8 *)data)[0] & ASSEMBLE_JSON_TYPE_MASK) != A_JT_ARRAY)
				{	
					printf("JSON: Error: Trying to call assemble_json_value_array_add_to_create with \"type\" set to A_JT_ARRAY, but the \"data\" param is not a pointer to an array.\n");
					return NULL;
				}
#endif
				memcpy(&member[1], &((uint8 *)data)[1], sizeof(void *) + sizeof(AJasonArrayCount));
				free(data);
			}else
			{
				for(i = 1; i < sizeof(void *) + sizeof(AJasonArrayCount) + 1; i++)
					member[i] = 0;
			}
		break;	
	}
	memcpy(&count, &array[1], sizeof(AJasonArrayCount));
	count++;
	if(after != NULL)
	{
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
		if(*after & ASSEMBLE_JSON_WRITE_PROTECTED)
		{	
			printf("JSON: Error: Trying to call assemble_json_value_array_add_to_create on a \"after\" value that is write protected\n");
			return NULL;
		}
		if(!(*after & ASSEMBLE_JSON_ARRAY))
		{	
			printf("JSON: Error: Trying to call assemble_json_value_array_add_to_create on a \"after\" value that is not an element of an array\n");
			return NULL;
		}
#endif	
		if(count == 1)
			count += ASSEMBLE_JSON_ARRAY_UNIFORM; // if this is the first member, make it uniform
		else if((type & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO != (after[0] & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO)			
			count %= ASSEMBLE_JSON_ARRAY_UNIFORM; // if this is not the same type as the last one, make it un-uniform
		memcpy(&member[assemble_type_size[*member]], &after[assemble_type_size[(*after & ASSEMBLE_JSON_TYPE_MASK)]], sizeof(void *));
		memcpy(&after[assemble_type_size[(*after & ASSEMBLE_JSON_TYPE_MASK)]], &member, sizeof(void *));
	}else
	{
		if(count == 1)
			count += ASSEMBLE_JSON_ARRAY_UNIFORM; // if this is the first member, make it uniform
		else if(count & ASSEMBLE_JSON_ARRAY_UNIFORM)
		{
			memcpy(&compare, &array[1 + sizeof(AJasonArrayCount)], sizeof(void *));
			if(type % A_JT_MODULO != (compare[0] & ASSEMBLE_JSON_TYPE_MASK) % A_JT_MODULO)			
				count %= ASSEMBLE_JSON_ARRAY_UNIFORM; // if this is not the same type as the last one, make it un-uniform
		}
		memcpy(&member[assemble_type_size[*member]], &array[1 + sizeof(AJasonArrayCount)], sizeof(void *));
		memcpy(&array[1 + sizeof(AJasonArrayCount)], &member, sizeof(void *));
	}
	memcpy(&array[1], &count, sizeof(AJasonArrayCount));
	member[0] |= ASSEMBLE_JSON_ARRAY;
	return member;
}

void *assemble_json_value_array_get_allocate(unsigned char *array, AJsonType output_array_type, uint *length)
{	
	AJasonArrayCount count;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if((*array & ASSEMBLE_JSON_TYPE_MASK) != A_JT_ARRAY)
	{	
		printf("JSON: Error: Trying to call assemble_json_value_array_first_get_uniform on a value that isnt an array\n");
		return NULL;
	}
#endif	
	memcpy(&count, &array[1],sizeof(AJasonArrayCount));
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
	if(!(count & ASSEMBLE_JSON_ARRAY_UNIFORM))
	{	
		printf("JSON: Error: Trying to call assemble_json_value_array_first_get_uniform on an array that doesnt have unified content\n");
		return NULL;
	}
#endif	
	count &= ~ASSEMBLE_JSON_ARRAY_UNIFORM;
	if(count == 0)
		return NULL;
	*length = count;
	switch(output_array_type)
	{
		case A_JT_BOOLEAN :
		{
			uint8 *output, *o;
			o = output = malloc((sizeof *output) * count);
			for(array = assemble_json_value_array_first_get(array); array != NULL; array = assemble_json_value_get_next(array))
				*o++ = (*array & ASSEMBLE_JSON_TYPE_MASK) == A_JT_TRUE;
			return output;
		}
		break;
		case A_JT_NUMBER_FLOAT :
		{
			float *output, *o;
			o = output = malloc((sizeof *output) * count);
			for(array = assemble_json_value_array_first_get(array); array != NULL; array = assemble_json_value_get_next(array))
				*o++ = assemble_json_value_number_get_float(array);
			return output;
		}
		break;
		case A_JT_NUMBER_DOUBLE :
		{
			double *output, *o;
			o = output = malloc((sizeof *output) * count);
			for(array = assemble_json_value_array_first_get(array); array != NULL; array = assemble_json_value_get_next(array))
				*o++ = assemble_json_value_number_get_double(array);
			return output;
		}
		break;
		case A_JT_NUMBER_DECIMAL :
		{
			AJsonDecimalNumber *output, *o;
			o = output = malloc((sizeof *output) * count);
			for(array = assemble_json_value_array_first_get(array); array != NULL; array = assemble_json_value_get_next(array))
			{
				assemble_json_value_number_get_decimal(array, o);
				o++;
			}
			return output;
		}
		break;
		case A_JT_STRING :
		{
			uint8 *member;
			char **output, *string;
			uint i = 0, j, length;
			output = malloc((sizeof *output) * count);
			for(member = assemble_json_value_array_first_get(array); member != NULL; member = assemble_json_value_get_next(member))
			{	
				string = assemble_json_value_string_get(member);
				for(j = 0; string[j] != 0; j++);
				output[i] = malloc((sizeof *string) * ++j);
				memcpy(output[i++], string, j);
			}
			return output;
		}
		break;
#ifdef ASSEMBLE_JSON_ENABLE_DEVELOPER_ERRORS
		default :
		printf("JSON: Error: Trying to call assemble_json_value_array_first_get_uniform with output_array_type that isnt, A_JT_BOOLEAN, A_JT_NUMBER_FLOAT, A_JT_NUMBER_DOUBLE, A_JT_NUMBER_DECIMAL or A_JT_STRING\n");
		return NULL;
#endif	
	}
}

/*
void json_test()
{
	unsigned char *value;
	value = assemble_json_value_allcoate(A_JT_FALSE, 0, "hello");
	assemble_json_print_allocate(value);
	value = assemble_json_value_allcoate(A_JT_TRUE, 0, "hello");
	assemble_json_print_allocate(value);
	value = assemble_json_value_allcoate(A_JT_NUMBER_FLOAT, 0, "hello");
	assemble_json_print_allocate(value);
	value = assemble_json_value_allcoate(A_JT_NUMBER_DOUBLE, 0, "hello");
	assemble_json_print_allocate(value);
	value = assemble_json_value_allcoate(A_JT_NUMBER_DECIMAL, 0, "hello");
	assemble_json_print_allocate(value);
	value = assemble_json_value_allcoate(A_JT_STRING, 0, "hello");
	assemble_json_print_allocate(value);
	value = assemble_json_value_allcoate(A_JT_OBJECT, 0, "hello");
	assemble_json_object_member_add_create(value, "name", A_JT_TRUE, "hello");
	assemble_json_print_allocate(value);
	value = assemble_json_value_allcoate(A_JT_ARRAY, 0, "hello");
	assemble_json_print_allocate(value);
}*/